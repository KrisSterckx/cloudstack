// Copyright 2012 Citrix Systems, Inc. Licensed under the
// Apache License, Version 2.0 (the "License"); you may not use this
// file except in compliance with the License.  Citrix Systems, Inc.
// reserves all rights not expressly granted by the License.
// You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Automatically generated by addcopyright.py at 04/03/2012
package com.cloud.network.element;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.ejb.Local;
import javax.inject.Inject;
import javax.naming.ConfigurationException;

import com.cloud.network.dao.NetworkVO;
import com.cloud.util.ExperimentalFeatureLoader;
import com.cloud.util.NuageVspUtil;
import com.cloud.utils.Pair;
import net.nuage.vsp.client.common.RequestType;
import net.nuage.vsp.client.common.model.ACLRule;
import net.nuage.vsp.client.common.model.ACLRule.ACLAction;
import net.nuage.vsp.client.common.model.ACLRule.ACLState;
import net.nuage.vsp.client.common.model.ACLRule.ACLTrafficType;
import net.nuage.vsp.client.common.model.NuageVspAPIParams;
import net.nuage.vsp.client.common.model.NuageVspAttribute;
import net.nuage.vsp.client.common.model.NuageVspEntity;
import net.nuage.vsp.client.exception.NuageVspAPIUtilException;
import net.nuage.vsp.client.rest.NuageVspApi;
import net.nuage.vsp.client.rest.NuageVspApiUtil;
import net.nuage.vsp.client.rest.NuageVspConstants;

import org.apache.cloudstack.api.InternalIdentity;
import org.apache.cloudstack.framework.config.dao.ConfigurationDao;
import org.apache.cloudstack.network.ExternalNetworkDeviceManager;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.math.RandomUtils;
import org.apache.log4j.Logger;

import com.cloud.agent.api.StartupCommand;
import com.cloud.agent.api.StartupNuageVspCommand;
import com.cloud.dc.DataCenter;
import com.cloud.dc.VlanVO;
import com.cloud.dc.dao.DataCenterDao;
import com.cloud.dc.dao.VlanDao;
import com.cloud.deploy.DeployDestination;
import com.cloud.domain.Domain;
import com.cloud.domain.dao.DomainDao;
import com.cloud.exception.ConcurrentOperationException;
import com.cloud.exception.InsufficientCapacityException;
import com.cloud.exception.ResourceUnavailableException;
import com.cloud.host.Host;
import com.cloud.host.HostVO;
import com.cloud.host.dao.HostDao;
import com.cloud.network.Network;
import com.cloud.network.Network.Capability;
import com.cloud.network.Network.Provider;
import com.cloud.network.Network.Service;
import com.cloud.network.NetworkModel;
import com.cloud.network.Networks;
import com.cloud.network.NuageVspDeviceVO;
import com.cloud.network.PhysicalNetworkServiceProvider;
import com.cloud.network.PublicIpAddress;
import com.cloud.network.dao.FirewallRulesCidrsDao;
import com.cloud.network.dao.FirewallRulesDao;
import com.cloud.network.dao.IPAddressDao;
import com.cloud.network.dao.IPAddressVO;
import com.cloud.network.dao.NetworkDao;
import com.cloud.network.dao.NetworkServiceMapDao;
import com.cloud.network.dao.NuageVspDao;
import com.cloud.network.manager.NuageVspManager;
import com.cloud.network.rules.FirewallRule;
import com.cloud.network.rules.FirewallRule.FirewallRuleType;
import com.cloud.network.rules.FirewallRule.Purpose;
import com.cloud.network.rules.FirewallRuleVO;
import com.cloud.network.rules.StaticNat;
import com.cloud.network.vpc.NetworkACLItem;
import com.cloud.network.vpc.NetworkACLItemDao;
import com.cloud.network.vpc.NetworkACLService;
import com.cloud.network.vpc.Vpc;
import com.cloud.network.vpc.dao.VpcDao;
import com.cloud.offering.NetworkOffering;
import com.cloud.offerings.NetworkOfferingVO;
import com.cloud.offerings.dao.NetworkOfferingDao;
import com.cloud.offerings.dao.NetworkOfferingServiceMapDao;
import com.cloud.resource.ResourceManager;
import com.cloud.resource.ResourceStateAdapter;
import com.cloud.resource.ServerResource;
import com.cloud.resource.UnableDeleteHostException;
import com.cloud.utils.component.AdapterBase;
import com.cloud.utils.db.DB;
import com.cloud.utils.db.EntityManager;
import com.cloud.vm.NicProfile;
import com.cloud.vm.NicVO;
import com.cloud.vm.ReservationContext;
import com.cloud.vm.VirtualMachineProfile;
import com.cloud.vm.dao.NicDao;

import static com.cloud.util.ExperimentalFeatureLoader.ExperimentalFeature.CONCURRENT_VSD_OPS;

@Local(value = {NetworkElement.class, ConnectivityProvider.class, IpDeployer.class, SourceNatServiceProvider.class, StaticNatServiceProvider.class, FirewallServiceProvider.class,
        DhcpServiceProvider.class})
public class NuageVspElement extends AdapterBase implements ConnectivityProvider, IpDeployer, SourceNatServiceProvider, StaticNatServiceProvider, FirewallServiceProvider,
        DhcpServiceProvider, ResourceStateAdapter {

    private static final Logger s_logger = Logger.getLogger(NuageVspElement.class);

    private static final Map<Service, Map<Capability, String>> capabilities = setCapabilities();

    public static final ExternalNetworkDeviceManager.NetworkDevice NuageVspDevice = new ExternalNetworkDeviceManager.NetworkDevice("NuageVsp", Provider.NuageVsp.getName());

    @Inject
    ResourceManager _resourceMgr;
    @Inject
    HostDao _hostDao;
    @Inject
    NetworkModel _networkModel;
    @Inject
    NetworkServiceMapDao _ntwkSrvcDao;
    @Inject
    NuageVspDao _nuageVspDao;
    @Inject
    NetworkDao _networkDao;
    @Inject
    protected DomainDao _domainDao;
    @Inject
    protected DataCenterDao _dcDao;
    @Inject
    IPAddressDao _ipAddressDao;
    @Inject
    VlanDao _vlanDao;
    @Inject
    NicDao _nicDao;
    @Inject
    VpcDao _vpcDao;
    @Inject
    NetworkOfferingServiceMapDao _ntwkOfferingSrvcDao;
    @Inject
    FirewallRulesDao _firewallDao;
    @Inject
    FirewallRulesCidrsDao _firewallCidrsDao;
    @Inject
    NetworkOfferingDao _ntwkOfferingDao;
    @Inject
    NetworkACLItemDao _networkACLItemDao;
    @Inject
    NetworkACLService _networkACLService;
    @Inject
    EntityManager _entityMgr;
    @Inject
    NuageVspManager _nuageVspManager;
    @Inject
    ConfigurationDao _configDao;
    @Inject
    ExperimentalFeatureLoader _expFeatureLoader;

    @Override
    public boolean applyIps(Network network, List<? extends PublicIpAddress> ipAddress, Set<Service> service) throws ResourceUnavailableException {
        return false;
    }

    @Override
    public Map<Service, Map<Capability, String>> getCapabilities() {
        return capabilities;
    }

    private static Map<Service, Map<Capability, String>> setCapabilities() {
        Map<Service, Map<Capability, String>> capabilities = new HashMap<Service, Map<Capability, String>>();

        // L2 Support : SDN provisioning
        capabilities.put(Service.Connectivity, null);

        // L3 Support : Generic
        capabilities.put(Service.Gateway, null);

        // Security Group
        capabilities.put(Service.SecurityGroup, null);

        // L3 Support : SourceNat
        Map<Capability, String> sourceNatCapabilities = new HashMap<Capability, String>();
        sourceNatCapabilities.put(Capability.SupportedSourceNatTypes, "perzone");
        sourceNatCapabilities.put(Capability.RedundantRouter, "false");
        capabilities.put(Service.SourceNat, sourceNatCapabilities);

        // L3 support : StaticNat
        capabilities.put(Service.StaticNat, null);

        // Set capabilities for Firewall service
        Map<Capability, String> firewallCapabilities = new HashMap<Capability, String>();
        firewallCapabilities.put(Capability.TrafficStatistics, "per public ip");
        firewallCapabilities.put(Capability.SupportedProtocols, "tcp,udp,icmp");
        firewallCapabilities.put(Capability.SupportedEgressProtocols, "tcp,udp,icmp, all");
        firewallCapabilities.put(Capability.SupportedTrafficDirection, "ingress, egress");
        firewallCapabilities.put(Capability.MultipleIps, "true");
        capabilities.put(Service.Firewall, firewallCapabilities);

        // L3 Support : DHCP
        Map<Capability, String> dhcpCapabilities = new HashMap<Capability, String>();
        capabilities.put(Service.Dhcp, dhcpCapabilities);

        return capabilities;
    }

    @Override
    public Provider getProvider() {
        return Provider.NuageVsp;
    }

    @Override
    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {
        super.configure(name, params);
        _resourceMgr.registerResourceStateAdapter(name, this);
        return true;
    }

    @Override
    public boolean implement(Network network, NetworkOffering offering, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException,
            ResourceUnavailableException, InsufficientCapacityException {
        if (s_logger.isDebugEnabled()) {
            s_logger.debug("Entering NuageVspElement implement function for network " + network.getName() + " (state " + network.getState() + ")");
        }

        if (!canHandle(network, Service.Connectivity)) {
            return false;
        }

        if (network.getBroadcastUri() == null) {
            s_logger.info("Nic has no broadcast Uri with the virtual router IP for network " + network.getName());
            return false;
        }

        Domain networksDomain = _domainDao.findById(network.getDomainId());
        NuageVspAPIParams nuageVspAPIParamsAsCmsUser;
        String enterpriseId;
        try {
            String nuageVspCmsId = NuageVspUtil.findNuageVspDeviceCmsIdByPhysNet(network.getPhysicalNetworkId(), _nuageVspDao, _configDao);
            nuageVspAPIParamsAsCmsUser = NuageVspApiUtil.getNuageVspAPIParametersAsCmsUser(getNuageVspHost(network.getPhysicalNetworkId()), nuageVspCmsId);
            enterpriseId = NuageVspApiUtil.getEnterprise(networksDomain.getUuid(), nuageVspAPIParamsAsCmsUser);
        } catch (NuageVspAPIUtilException exception) {
            s_logger.error("Exception occurred while executing implement API. So, FIP clean up could not be execued successfully. Retry restarting the network "
                    + network.getName());
            return true;
        }

        if (s_logger.isDebugEnabled()) {
            s_logger.debug("Starting the sync for network " + network.getName() + " at " + new Date());
        }
        Long vpcId = network.getVpcId();
        // apply firewall rules
        if (vpcId == null && _networkModel.areServicesSupportedByNetworkOffering(offering.getId(), Service.Firewall)) {
            if (s_logger.isDebugEnabled()) {
                s_logger.debug("Started Sync Ingress Firewall Rule for network " + network.getName() + " at " + new Date());
            }
            List<FirewallRuleVO> firewallIngressRulesToApply = _firewallDao.listByNetworkPurposeTrafficType(network.getId(), Purpose.Firewall, FirewallRule.TrafficType.Ingress);
            for (FirewallRuleVO rule : firewallIngressRulesToApply) {
                // load cidrs if any
                rule.setSourceCidrList(_firewallCidrsDao.getSourceCidrs(rule.getId()));
            }
            applyACLRules(network, firewallIngressRulesToApply, false, true, false);
            if (s_logger.isDebugEnabled()) {
                s_logger.debug("Finished Sync Ingress Firewall Rule for network " + network.getName() + " at " + new Date());
            }

            if (s_logger.isDebugEnabled()) {
                s_logger.debug("started Sync Egress Firewall Rule for network " + network.getName() + " at " + new Date());
            }
            List<FirewallRuleVO> firewallEgressRulesToApply = _firewallDao.listByNetworkPurposeTrafficType(network.getId(), Purpose.Firewall, FirewallRule.TrafficType.Egress);
            for (FirewallRuleVO rule : firewallEgressRulesToApply) {
                // load cidrs if any
                rule.setSourceCidrList(_firewallCidrsDao.getSourceCidrs(rule.getId()));
            }
            applyACLRules(network, firewallEgressRulesToApply, false, false, false);
            if (s_logger.isDebugEnabled()) {
                s_logger.debug("Finished Sync Egress Firewall Rule for network " + network.getName() + " at " + new Date());
            }
        }

        if (s_logger.isDebugEnabled()) {
            s_logger.debug("Started Sync of Static NAT for network " + network.getName() + " at " + new Date());
        }
        //This method is called when a Network is restarted with cleanup true or false. Also, when the network is newly created
        //We can handle the logic to clean all the stale Static Ips
        //Get all the NAT public IPs associated with the network
        List<IPAddressVO> ips = _ipAddressDao.listStaticNatPublicIps(network.getId());
        List<String> acsFipUuid = new ArrayList<String>();
        //Clean all the FIP that is stale in
        for (IPAddressVO ip : ips) {
            acsFipUuid.add(ip.getUuid());
        }
        try {
            //Get the L3 Domain or L2 Domain corresponding to the network
            NuageVspEntity attachedNetworkType = null;
            NetworkOfferingVO networkOferringVO = _ntwkOfferingDao.findById(network.getNetworkOfferingId());
            String vpcOrSubnetUuid = null;
            String vspNetworkId = null;
            Pair<String, String> vsdDomainAndSubnetId;
            if (vpcId != null) {
                Vpc vpcObj = _vpcDao.findById(vpcId);
                vpcOrSubnetUuid = vpcObj.getUuid();
                vsdDomainAndSubnetId = NuageVspApiUtil.getIsolatedSubNetwork(enterpriseId, network.getUuid(), nuageVspAPIParamsAsCmsUser, vpcObj.getUuid());
            } else {
                vpcOrSubnetUuid = network.getUuid();
                vsdDomainAndSubnetId = NuageVspApiUtil.getIsolatedSubNetwork(enterpriseId, network.getUuid(), nuageVspAPIParamsAsCmsUser);
            }
            vspNetworkId = vsdDomainAndSubnetId.second();
            long networkOfferingId = networkOferringVO.getId();
            if (_ntwkOfferingSrvcDao.areServicesSupportedByNetworkOffering(networkOfferingId, Service.SourceNat)
                    || _ntwkOfferingSrvcDao.areServicesSupportedByNetworkOffering(networkOfferingId, Service.StaticNat)
                    || _ntwkOfferingSrvcDao.areServicesSupportedByNetworkOffering(networkOfferingId, Service.Connectivity)) {
                attachedNetworkType = NuageVspEntity.DOMAIN;
            } else {
                attachedNetworkType = NuageVspEntity.L2DOMAIN;
            }
            String attachedL2DomainOrDomainId = NuageVspApiUtil.getIsolatedDomain(enterpriseId, vpcOrSubnetUuid, attachedNetworkType, nuageVspAPIParamsAsCmsUser);

            List<String> dnsServers = _nuageVspManager.getDnsDetails(network);
            try {
                s_logger.debug("Started Sync of DNS Server setting for network " + network.getName() + " at " + new Date());
                NuageVspApiUtil.createDhcpOptions(network.getName(), dnsServers, network.getUuid(), nuageVspAPIParamsAsCmsUser, vspNetworkId,
                        attachedNetworkType.equals(NuageVspEntity.L2DOMAIN) ? NuageVspEntity.L2DOMAIN : NuageVspEntity.SUBNET, "", false, new StringBuffer());
            } catch (Exception e1) {
                s_logger.warn("Failed to update the DNS Server information for network " + network.getName());
            }
            s_logger.debug("Finished Sync of DNS Server setting for network " + network.getName() + " at " + new Date());

            //Get all the Floating Ips associated to this network filtered by the Floating IP's External ID that has networkUUID:publicIPUUID
            //example : externalID beginswith 'networkUuid'
            String fipExternalIdFilter = NuageVspAttribute.EXTERNAL_ID.getAttributeName() + " beginswith '" + network.getUuid() + "'";
            String floatingIpsAssoToNetwork = NuageVspApiUtil.findEntityUsingFilter(attachedNetworkType.equals(NuageVspEntity.L2DOMAIN) ? NuageVspEntity.L2DOMAIN
                    : NuageVspEntity.DOMAIN, attachedL2DomainOrDomainId, NuageVspEntity.FLOATING_IP, fipExternalIdFilter, nuageVspAPIParamsAsCmsUser);
            if (StringUtils.isNotBlank(floatingIpsAssoToNetwork)) {
                List<Map<String, Object>> fips = NuageVspApiUtil.parseJson(floatingIpsAssoToNetwork, NuageVspEntity.FLOATING_IP);
                for (Map<String, Object> fip : fips) {
                    String fipId = fip.get(NuageVspAttribute.ID.getAttributeName()).toString();
                    String externalId = fip.get(NuageVspAttribute.EXTERNAL_ID.getAttributeName()).toString();
                    String fipIp = (String)fip.get(NuageVspAttribute.FLOATING_IP_ADDRESS.getAttributeName());
                    if (!acsFipUuid.contains(externalId.substring(externalId.indexOf(":") + 1))) {
                        if (s_logger.isDebugEnabled()) {
                            s_logger.debug("Floating IP " + fipIp + " with " + externalId + " does not exists in ACS network " + network.getName()
                                    + ". So, processing to clean the stale FIP from VSP");
                        }
                        //get the all VPorts and check for the FIP associated to it
                        String vportJson = null;
                        try {
                            vportJson = NuageVspApi.executeRestApi(RequestType.GETALL, nuageVspAPIParamsAsCmsUser.getCloudstackDomainName(),
                                    nuageVspAPIParamsAsCmsUser.getCurrentUserName(), NuageVspEntity.FLOATING_IP, fipId, NuageVspEntity.VPORT, null,
                                    nuageVspAPIParamsAsCmsUser.getRestRelativePath(), nuageVspAPIParamsAsCmsUser.getCmsUserInfo(), nuageVspAPIParamsAsCmsUser.getNoofRetry(),
                                    nuageVspAPIParamsAsCmsUser.getRetryInterval(), nuageVspAPIParamsAsCmsUser.isCmsUser(), nuageVspAPIParamsAsCmsUser.getNuageVspCmsId());
                        } catch (Exception e) {
                            if (s_logger.isDebugEnabled()) {
                                s_logger.debug("Failed to get VPorts from VSP during FIP clean up. " + e.getMessage());
                            }
                        }

                        if (StringUtils.isNotBlank(vportJson)) {
                            List<Map<String, Object>> vports = NuageVspApiUtil.parseJson(vportJson, NuageVspEntity.VPORT);
                            for (Map<String, Object> vport : vports) {
                                if (StringUtils.equals((String)vport.get(NuageVspAttribute.VPORT_FLOATING_IP_ID.getAttributeName()), fipId)) {
                                    NuageVspApiUtil.updateVPortWithFloatingIPId((String)vport.get(NuageVspAttribute.ID.getAttributeName()), nuageVspAPIParamsAsCmsUser, null);
                                    if (s_logger.isDebugEnabled()) {
                                        s_logger.debug("Found a VPort " + vport + " that is associated the stale FIP in network " + network.getName()
                                                + ". Removed the association to clean the FIP " + fipIp);
                                    }
                                }
                            }
                        }
                        if (s_logger.isDebugEnabled()) {
                            s_logger.debug("Clean the stale FIP " + fipIp + " associated to network " + network.getName() + " from VSP");
                        }
                        NuageVspApiUtil.cleanUpVspStaleObjects(NuageVspEntity.FLOATING_IP, fipId, nuageVspAPIParamsAsCmsUser);
                    }
                }
            }
        } catch (NuageVspAPIUtilException exception) {
            s_logger.error("Exception occurred while executing implement API. So, FIP clean up could not be execued successfully. Retry restarting the network "
                    + network.getName());
        }
        if (s_logger.isDebugEnabled()) {
            s_logger.debug("Finished Sync of Static NAT for network " + network.getName() + " at " + new Date());
            s_logger.debug("Finished the sync for network " + network.getName() + " at " + new Date());
        }
        return true;
    }

    protected boolean usesPreconfiguredDomainTemplate(Network network) throws NuageVspAPIUtilException {
        try {
            Domain networksDomain = _domainDao.findById(network.getDomainId());
            NetworkOffering networkOffering = _ntwkOfferingDao.findById(network.getNetworkOfferingId());
            String nuageVspCmsId = NuageVspUtil.findNuageVspDeviceCmsIdByPhysNet(network.getPhysicalNetworkId(), _nuageVspDao, _configDao);
            NuageVspAPIParams nuageVspAPIParamsAsCmsUser = NuageVspApiUtil.getNuageVspAPIParametersAsCmsUser(getNuageVspHost(network.getPhysicalNetworkId()), nuageVspCmsId);
            String enterpriseId = NuageVspApiUtil.getEnterprise(networksDomain.getUuid(), nuageVspAPIParamsAsCmsUser);
            boolean shared = networkOffering.getGuestType() == Network.GuestType.Shared;
            return usesPreconfiguredDomainTemplate(nuageVspAPIParamsAsCmsUser, enterpriseId, false, shared, network.getUuid());
        } catch (NuageVspAPIUtilException exception) {
            s_logger.error("Exception occurred while executing implement API. So, FIP clean up could not be execued successfully. Retry restarting the network "
                    + network.getName());
            throw exception;
        }
    }

    protected boolean usesPreconfiguredDomainTemplate(Vpc vpc, Network network) throws NuageVspAPIUtilException {
        try {
            Domain networksDomain = _domainDao.findById(network.getDomainId());
            String nuageVspCmsId = NuageVspUtil.findNuageVspDeviceCmsIdByPhysNet(network.getPhysicalNetworkId(), _nuageVspDao, _configDao);
            NuageVspAPIParams nuageVspAPIParamsAsCmsUser = NuageVspApiUtil.getNuageVspAPIParametersAsCmsUser(getNuageVspHost(network.getPhysicalNetworkId()), nuageVspCmsId);
            String enterpriseId = NuageVspApiUtil.getEnterprise(networksDomain.getUuid(), nuageVspAPIParamsAsCmsUser);
            return usesPreconfiguredDomainTemplate(nuageVspAPIParamsAsCmsUser, enterpriseId, true, false, vpc.getUuid());
        } catch (NuageVspAPIUtilException exception) {
            s_logger.error("Exception occurred while executing implement API. So, FIP clean up could not be execued successfully. Retry restarting the network "
                    + network.getName());
            throw exception;
        }
    }

    protected boolean usesPreconfiguredDomainTemplate(NuageVspAPIParams nuageVspAPIParamsAsCmsUser, String enterpriseId, boolean isVpc, boolean isShared, String networkUuid) throws NuageVspAPIUtilException {
        String preConfiguredDomainTemplateName;
        if (isVpc) {
            preConfiguredDomainTemplateName = _configDao.getValue(NuageVspManager.NuageVspVpcDomainTemplateName.key());
        } else if (isShared) {
            preConfiguredDomainTemplateName = _configDao.getValue(NuageVspManager.NuageVspSharedNetworkDomainTemplateName.key());
        } else {
            preConfiguredDomainTemplateName = _configDao.getValue(NuageVspManager.NuageVspIsolatedNetworkDomainTemplateName.key());
        }

        String domainTemplateId = NuageVspApiUtil.findFieldValueByExternalUuid(NuageVspEntity.ENTERPRISE, enterpriseId, NuageVspEntity.DOMAIN,
                networkUuid, NuageVspAttribute.DOMAIN_TEMPLATE_ID.getAttributeName(), nuageVspAPIParamsAsCmsUser);
        String preConfiguredDomainTemplateEntity = NuageVspApiUtil.findEntityUsingFilter(NuageVspEntity.ENTERPRISE, enterpriseId, NuageVspEntity.DOMAIN_TEMPLATE,
                "name", preConfiguredDomainTemplateName, nuageVspAPIParamsAsCmsUser);
        String preConfiguredDomainTemplateId = NuageVspApiUtil.getEntityId(preConfiguredDomainTemplateEntity, NuageVspEntity.DOMAIN_TEMPLATE);
        if (StringUtils.isBlank(domainTemplateId) || StringUtils.isBlank(preConfiguredDomainTemplateId)) {
            return false;
        }
        return domainTemplateId.equals(preConfiguredDomainTemplateId);
    }

    @Override
    public boolean prepare(Network network, NicProfile nic, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException,
            ResourceUnavailableException, InsufficientCapacityException {
        if (!canHandle(network, Service.Connectivity)) {
            return false;
        }

        if (network.getBroadcastUri() == null) {
            s_logger.info("Nic has no broadcast Uri with the virtual router IP for network " + network.getName());
            return false;
        }

        return true;
    }

    @Override
    public boolean release(Network network, NicProfile nic, VirtualMachineProfile vm, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {
        if (!canHandle(network, Service.Connectivity)) {
            return false;
        }

        if (network.getBroadcastUri() == null) {
            s_logger.info("Nic has no broadcast Uri with the virtual router IP for network " + network.getName());
            return false;
        }

        return true;
    }

    @Override
    public boolean shutdown(Network network, ReservationContext context, boolean cleanup) throws ConcurrentOperationException, ResourceUnavailableException {
        if (!canHandle(network, Service.Connectivity)) {
            return false;
        }

        return true;
    }

    @Override
    public boolean isReady(PhysicalNetworkServiceProvider provider) {
        return true;
    }

    @Override
    public boolean shutdownProviderInstances(PhysicalNetworkServiceProvider provider, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {
        return true;
    }

    @Override
    public boolean canEnableIndividualServices() {
        return true;
    }

    @Override
    public boolean destroy(Network network, ReservationContext context) throws ConcurrentOperationException, ResourceUnavailableException {
        if (!canHandle(network, Service.Connectivity)) {
            return false;
        }

        return true;
    }

    @Override
    public boolean verifyServicesCombination(Set<Service> services) {
        // This element can only function in a Nuage based
        // SDN network, so Connectivity needs to be present here
        if (!services.contains(Service.Connectivity)) {
            s_logger.warn("Unable to support services combination without Connectivity service provided by Nuage VSP.");
            return false;
        }

        if ((services.contains(Service.StaticNat)) && (!services.contains(Service.SourceNat))) {
            s_logger.warn("Unable to provide StaticNat without the SourceNat service.");
            return false;
        }

        if (services.contains(Service.Vpn) || services.contains(Service.Dns) || services.contains(Service.Lb) || services.contains(Service.PortForwarding)
                || services.contains(Service.NetworkACL)) {
            // We don't implement any of these services, and we don't
            // want anyone else to do it for us. So if these services
            // exist, we can't handle it.
            s_logger.warn("Unable to support services combination. The services list " + services + " contains service(s) not supported by Nuage VSP.");
            return false;
        }

        return true;
    }

    @Override
    public boolean canDisable(PhysicalNetworkServiceProvider provider) {
        Long physicalNetworkId = provider.getPhysicalNetworkId();
        List<NetworkVO> networkList = _networkDao.listByPhysicalNetwork(physicalNetworkId);
        for (NetworkVO network : networkList) {
            if (network.getBroadcastDomainType() == Networks.BroadcastDomainType.Vsp) {
                if ((network.getState() != Network.State.Shutdown) && (network.getState() != Network.State.Destroy)) {
                    return false;
                }
            }
        }
        return true;
    }

    protected boolean canHandle(Network network, Service service) {

        if (network.getBroadcastDomainType() != Networks.BroadcastDomainType.Vsp) {
            return false;
        }

        if (!_networkModel.isProviderForNetwork(getProvider(), network.getId())) {
            s_logger.debug("NuageVspElement is not a provider for network " + network.getDisplayText());
            return false;
        }

        if (!_networkModel.isProviderEnabledInPhysicalNetwork(network.getPhysicalNetworkId(), getProvider().getName())) {
            s_logger.debug("NuageVspElement is not enabled for physical network " + network.getPhysicalNetworkId());
            return false;
        }

        if (service != null) {
            if (!_ntwkSrvcDao.canProviderSupportServiceInNetwork(network.getId(), service, getProvider())) {
                s_logger.debug("NuageVspElement can't provide the " + service.getName() + " service on network " + network.getDisplayText());
                return false;
            }
        }

        return true;
    }

    @Override
    public boolean addDhcpEntry(Network network, NicProfile nic, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context) throws ConcurrentOperationException,
            InsufficientCapacityException, ResourceUnavailableException {
        return true;
    }

    @Override
    public boolean configDhcpSupportForSubnet(Network network, NicProfile nic, VirtualMachineProfile vm, DeployDestination dest, ReservationContext context)
            throws ConcurrentOperationException, InsufficientCapacityException, ResourceUnavailableException {
        return true;
    }

    @Override
    public boolean removeDhcpSupportForSubnet(Network network) throws ResourceUnavailableException {
        return true;
    }

    @Override
    @DB
    public boolean applyStaticNats(Network config, List<? extends StaticNat> rules) throws ResourceUnavailableException {
        if (!canHandle(config, Service.StaticNat)) {
            return false;
        }

        //Check if the network is associated to a VPC
        Long vpcId = config.getVpcId();
        Domain networksDomain = _domainDao.findById(config.getDomainId());
        DataCenter dc = _dcDao.findById(config.getDataCenterId());
        NuageVspAPIParams nuageVspAPIParamsAsCmsUser;
        try {
            String nuageVspCmsId = NuageVspUtil.findNuageVspDeviceCmsIdByPhysNet(config.getPhysicalNetworkId(), _nuageVspDao, _configDao);
            nuageVspAPIParamsAsCmsUser = NuageVspApiUtil.getNuageVspAPIParametersAsCmsUser(getNuageVspHost(config.getPhysicalNetworkId()), nuageVspCmsId);
        } catch (NuageVspAPIUtilException e) {
            throw new ResourceUnavailableException(e.getMessage(), Domain.class, dc.getId());
        }

        boolean useConcurrentVsdOps = _expFeatureLoader.isExperimentalFeatureEnabledForPhysicalNetwork(config.getPhysicalNetworkId(), CONCURRENT_VSD_OPS);
        if (!useConcurrentVsdOps) {
            long configId = config.getId();
            config = _networkDao.acquireInLockTable(config.getId(), 1200);
            if (config == null) {
                throw new ConcurrentOperationException("Unable to acquire lock on network " + configId);
            }
        }

        try {
            //Below is a hack to figure out the domain or l2 domain to which the floating Ip is attached to
            //This is useful to delete the FLoating IP when we can not get VM information from the StaticNat
            String enterpriseId;
            String attachedL2DomainOrDomainId;
            NuageVspEntity attachedNetworkType;
            String vspNetworkId;
            String vpcOrSubnetUuid = null;
            boolean isVpc = false;
            try {
                enterpriseId = NuageVspApiUtil.getEnterprise(networksDomain.getUuid(), nuageVspAPIParamsAsCmsUser);
                Pair<String, String> vsdDomainAndSubnetId;
                if (vpcId != null) {
                    Vpc vpcObj = _vpcDao.findById(vpcId);
                    vpcOrSubnetUuid = vpcObj.getUuid();
                    vsdDomainAndSubnetId = NuageVspApiUtil.getIsolatedSubNetwork(enterpriseId, config.getUuid(), nuageVspAPIParamsAsCmsUser, vpcObj.getUuid());
                    isVpc = true;
                } else {
                    vpcOrSubnetUuid = config.getUuid();
                    vsdDomainAndSubnetId = NuageVspApiUtil.getIsolatedSubNetwork(enterpriseId, config.getUuid(), nuageVspAPIParamsAsCmsUser);
                }
                vspNetworkId = vsdDomainAndSubnetId.second();
                long networkOfferingId = _ntwkOfferingDao.findById(config.getNetworkOfferingId()).getId();
                if (_ntwkOfferingSrvcDao.areServicesSupportedByNetworkOffering(networkOfferingId, Service.SourceNat)
                        || _ntwkOfferingSrvcDao.areServicesSupportedByNetworkOffering(networkOfferingId, Service.StaticNat)
                        || _ntwkOfferingSrvcDao.areServicesSupportedByNetworkOffering(networkOfferingId, Service.Connectivity)) {
                    attachedNetworkType = NuageVspEntity.DOMAIN;
                } else {
                    attachedNetworkType = NuageVspEntity.L2DOMAIN;
                }
                attachedL2DomainOrDomainId = NuageVspApiUtil.getIsolatedDomain(enterpriseId, vpcOrSubnetUuid, attachedNetworkType, nuageVspAPIParamsAsCmsUser);
            } catch (NuageVspAPIUtilException e1) {
                throw new ResourceUnavailableException(e1.getMessage(), Network.class, config.getId());
            }

            for (StaticNat staticNat : rules) {
                IPAddressVO sourceNatIp = _ipAddressDao.findById(staticNat.getSourceIpAddressId());
                VlanVO sourceNatVan = _vlanDao.findById(sourceNatIp.getVlanId());
                NicVO nicVO = _nicDao.findByIp4AddressAndNetworkId(staticNat.getDestIpAddress(), staticNat.getNetworkId());
                try {
                    if (nicVO == null) {
                        if (staticNat.isForRevoke()) {
                            //this is case where the VM was deleted without disabling the Static NAT
                            //We need to find the Subnet and Domain to which this StaticNat belongs to...
                            if (s_logger.isDebugEnabled()) {
                                s_logger.debug("Static NAT " + sourceNatIp.getAddress().addr() + "(" + sourceNatIp.getUuid() + ")" + " associated to network " + config.getName()
                                        + " is in Revoke state but it is not associated to any NIC in Cloudstack(nicVO=null). So, floating IP needs to be disassociated from VPort and deleted from VSP");
                            }
                            //this is the case where we know that vportId is null so set it to "" so that we do not query VPorts in VSP to find the VPort that has the FIP
                            NuageVspApiUtil.releaseFIPFromVsp(config.getUuid(), sourceNatIp.getUuid(), attachedL2DomainOrDomainId, "", vspNetworkId,
                                    attachedNetworkType, nuageVspAPIParamsAsCmsUser, isVpc);
                        } else {
                            s_logger.debug("Static NAT " + sourceNatIp.getAddress().addr() + "(" + sourceNatIp.getUuid() + ")" + " associated to network " + config.getName()
                                    + " is not in Revoke state but NIC is null.");
                        }
                    } else {
                        //VM Interface information and get its corresponding VPort
                        String vportId = null;
                        String domainId = null;
                        String vmInterfaceJson = null;
                        if (attachedNetworkType.equals(NuageVspEntity.DOMAIN)) {
                            vmInterfaceJson = NuageVspApi.executeRestApi(RequestType.GETALL, nuageVspAPIParamsAsCmsUser.getCloudstackDomainName(),
                                    nuageVspAPIParamsAsCmsUser.getCurrentUserName(), NuageVspEntity.SUBNET, vspNetworkId, NuageVspEntity.VM_INTERFACE, NuageVspAttribute.VM_INTERFACE_MAC.getAttributeName() + " == '"
                                            + nicVO.getMacAddress() + "'", nuageVspAPIParamsAsCmsUser.getRestRelativePath(), nuageVspAPIParamsAsCmsUser.getCmsUserInfo(),
                                    nuageVspAPIParamsAsCmsUser.getNoofRetry(), nuageVspAPIParamsAsCmsUser.getRetryInterval(), nuageVspAPIParamsAsCmsUser.isCmsUser(), nuageVspAPIParamsAsCmsUser.getNuageVspCmsId());
                        } else {
                            vmInterfaceJson = NuageVspApi.executeRestApi(RequestType.GETALL, nuageVspAPIParamsAsCmsUser.getCloudstackDomainName(),
                                    nuageVspAPIParamsAsCmsUser.getCurrentUserName(), NuageVspEntity.L2DOMAIN, attachedL2DomainOrDomainId, NuageVspEntity.VM_INTERFACE, NuageVspAttribute.VM_INTERFACE_MAC.getAttributeName() + " == '"
                                            + nicVO.getMacAddress() + "'", nuageVspAPIParamsAsCmsUser.getRestRelativePath(), nuageVspAPIParamsAsCmsUser.getCmsUserInfo(),
                                    nuageVspAPIParamsAsCmsUser.getNoofRetry(), nuageVspAPIParamsAsCmsUser.getRetryInterval(), nuageVspAPIParamsAsCmsUser.isCmsUser(), nuageVspAPIParamsAsCmsUser.getNuageVspCmsId());
                        }
                        if (StringUtils.isNotBlank(vmInterfaceJson)) {
                            //get the VportId from VMInterface
                            List<Map<String, Object>> vmInterfaceDetails = NuageVspApiUtil.parseJson(vmInterfaceJson, NuageVspEntity.VM_INTERFACE);
                            vportId = (String)vmInterfaceDetails.iterator().next().get(NuageVspAttribute.VM_INTERFACE_VPORT_ID.getAttributeName());
                            domainId = (String)vmInterfaceDetails.iterator().next().get(NuageVspAttribute.VM_INTERFACE_DOMAIN_ID.getAttributeName());
                            String attachedDomainType = (String)vmInterfaceDetails.iterator().next().get(NuageVspAttribute.VM_INTERFACE_ATTACHED_NETWORK_TYPE.getAttributeName());
                            if (domainId == null && attachedDomainType.equals(NuageVspEntity.L2DOMAIN.name())) {
                                //This is a case where the VM is attached to L2Domain
                                domainId = (String)vmInterfaceDetails.iterator().next().get(NuageVspAttribute.VM_INTERFACE_ATTACHED_NETWORK_ID.getAttributeName());
                            }
                        } else {
                            s_logger.debug("Static NAT " + sourceNatIp.getAddress().addr() + "(" + sourceNatIp.getUuid() + ")" + " associated to network " + config.getName()
                                    + " is in revoke=" + staticNat.isForRevoke() + " state but NIC does not exists in VSD. VSD Domain id used to process FIP is "
                                    + attachedL2DomainOrDomainId);
                        }
                        if (staticNat.isForRevoke()) {
                            if (s_logger.isDebugEnabled()) {
                                s_logger.debug("Static NAT " + sourceNatIp.getAddress().addr() + "(" + sourceNatIp.getUuid() + ") associated to network " + config.getName()
                                        + " is disassociated from the VM interface " + nicVO.getIp4Address() + ". So, disassociate the Floating IP from VM's VPort " + vportId
                                        + " and delete the Floating IP");
                            }
                            NuageVspApiUtil.releaseFIPFromVsp(config.getUuid(), sourceNatIp.getUuid(), domainId != null ? domainId : attachedL2DomainOrDomainId,
                                    vportId, vspNetworkId, attachedNetworkType, nuageVspAPIParamsAsCmsUser, isVpc);
                        } else {
                            NuageVspApiUtil.applyStaticNatInVSP(config.getName(), config.getUuid(), nuageVspAPIParamsAsCmsUser, attachedL2DomainOrDomainId, attachedNetworkType, vspNetworkId,
                                    vpcOrSubnetUuid, isVpc, sourceNatIp.getAddress().addr(), sourceNatIp.getUuid(), sourceNatVan.getVlanGateway(), sourceNatVan.getVlanNetmask(),
                                    sourceNatVan.getUuid(), nicVO.getIp4Address(), nicVO.getUuid(), vportId, domainId);
                        }
                    }
                } catch (Exception e) {
                    s_logger.error("Exception happened while applying Static NAT for network " + config.getName() + ". " + e.getMessage());
                    throw new ResourceUnavailableException(e.getMessage(), DataCenter.class, dc.getId());
                }
            }
        } finally {
            if (config != null && !useConcurrentVsdOps) {
                _networkDao.releaseFromLockTable(config.getId());
            }
        }

        return true;
    }

    @Override
    public IpDeployer getIpDeployer(Network network) {
        return this;
    }

    @Override
    public boolean applyFWRules(Network network, List<? extends FirewallRule> rules) throws ResourceUnavailableException {
        if (!canHandle(network, Service.Firewall)) {
            return false;
        }

        s_logger.debug("Handling applyFWRules for network " + network.getName() + " with " + rules.size() + " FWRules");
        return applyACLRules(network, rules, false, rules.size() > 0 ? (((FirewallRule)rules.iterator().next()).getTrafficType().equals(FirewallRule.TrafficType.Ingress) ? true
                : false) : null, false);
    }

    @DB
    protected boolean applyACLRules(Network network, List<? extends InternalIdentity> rules, boolean isNetworkAcl, Boolean isAcsIngressAcl, boolean networkReset)
            throws ResourceUnavailableException {
        int random = RandomUtils.nextInt(1000);
        long initialStartTime = System.currentTimeMillis();
        String networkName = network.getName();

        boolean useConcurrentVsdOps = _expFeatureLoader.isExperimentalFeatureEnabledForPhysicalNetwork(network.getPhysicalNetworkId(), CONCURRENT_VSD_OPS);
        if (!useConcurrentVsdOps) {
            long networkId = network.getId();
            network = _networkDao.acquireInLockTable(network.getId(), 1200);
            if (network == null) {
                s_logger.error("Network " + networkName + "(" + random + ")  Failed to acquire the lock even after " + (System.currentTimeMillis() - initialStartTime));
                throw new ConcurrentOperationException("Unable to acquire lock on network " + networkId);
            }
        }

        try {

            long lockacquiredtime = System.currentTimeMillis();
            Domain networksDomain = _domainDao.findById(network.getDomainId());
            NuageVspEntity attachedNetworkType = null;
            String enterpriseId = null;
            String attachedL2DomainOrDomainId = null;
            NetworkOfferingVO networkOferringVO = _ntwkOfferingDao.findById(network.getNetworkOfferingId());
            String ingressACLTempId = null;
            String egressACLTempId = null;
            NuageVspAPIParams nuageVspAPIParamsAsCmsUser = null;
            try {
                String nuageVspCmsId = NuageVspUtil.findNuageVspDeviceCmsIdByPhysNet(network.getPhysicalNetworkId(), _nuageVspDao, _configDao);
                nuageVspAPIParamsAsCmsUser = NuageVspApiUtil.getNuageVspAPIParametersAsCmsUser(getNuageVspHost(network.getPhysicalNetworkId()), nuageVspCmsId);
                String vpcOrSubnetUuid = null;

                boolean usesPreConfiguredDomainTemplate;
                if (network.getVpcId() != null) {
                    Vpc vpc = _vpcDao.findById(network.getVpcId());
                    usesPreConfiguredDomainTemplate = usesPreconfiguredDomainTemplate(vpc, network);
                } else {
                    usesPreConfiguredDomainTemplate = usesPreconfiguredDomainTemplate(network);
                }

                //This hack is to avoid creating a system ACL that get added by default by CS in case of FirewallRule
                if (rules != null && rules.size() == 1) {
                    InternalIdentity rule = rules.iterator().next();
                    if ((rule instanceof FirewallRule) && ((FirewallRule)rule).getType().equals(FirewallRuleType.System)) {
                        if (s_logger.isDebugEnabled()) {
                            s_logger.debug("Default ACL added by CS as system is ignored for network " + network.getName() + " with rule " + rules);
                        }
                        return true;
                    }
                }

                // CLOUD-465 : Remove these lines when we want to re-enable CloudStack ACL rules when using a preconfigured domain template
                if (usesPreConfiguredDomainTemplate && CollectionUtils.isNotEmpty(rules)) {
                    boolean success = true;
                    for (InternalIdentity rule : rules) {
                        if (rule instanceof FirewallRule) {
                            FirewallRule fwRule = (FirewallRule) rule;
                            success = fwRule.getState() == FirewallRule.State.Revoke || fwRule.getState() == FirewallRule.State.Deleting;
                        } else if (rule instanceof NetworkACLItem) {
                            NetworkACLItem aclRule = (NetworkACLItem) rule;
                            success = aclRule.getState() == NetworkACLItem.State.Revoke;
                        }

                        if (!success) break;
                    }

                    if (!success) {
                        s_logger.info("CloudStack ACLs are not supported with Nuage Preconfigured Domain Template");
                        throw new NuageVspAPIUtilException("CloudStack ACLs are not supported with Nuage Preconfigured Domain Template");
                    }
                    return true;
                }

                try {
                    enterpriseId = NuageVspApiUtil.getEnterprise(networksDomain.getUuid(), nuageVspAPIParamsAsCmsUser);
                    Long vpcId = network.getVpcId();
                    if (vpcId != null) {
                        Vpc vpcObj = _vpcDao.findById(vpcId);
                        vpcOrSubnetUuid = vpcObj.getUuid();
                    } else {
                        vpcOrSubnetUuid = network.getUuid();
                    }
                    long networkOfferingId = networkOferringVO.getId();
                    if (_ntwkOfferingSrvcDao.areServicesSupportedByNetworkOffering(networkOfferingId, Service.SourceNat)
                            || _ntwkOfferingSrvcDao.areServicesSupportedByNetworkOffering(networkOfferingId, Service.StaticNat)
                            || _ntwkOfferingSrvcDao.areServicesSupportedByNetworkOffering(networkOfferingId, Service.Connectivity)) {
                        attachedNetworkType = NuageVspEntity.DOMAIN;
                    } else {
                        attachedNetworkType = NuageVspEntity.L2DOMAIN;
                    }
                    attachedL2DomainOrDomainId = NuageVspApiUtil.getIsolatedDomain(enterpriseId, vpcOrSubnetUuid, attachedNetworkType, nuageVspAPIParamsAsCmsUser);
                } catch (NuageVspAPIUtilException exception) {
                    if (s_logger.isDebugEnabled()) {
                        s_logger.debug("Enterprise or Domain does not exists in VSP. So, ACLs update is ignored for network " + network.getName() + ". " + exception.getMessage());
                    }
                }

                if (StringUtils.isNotBlank(attachedL2DomainOrDomainId)) {
                    //Get all the Ingress and Egress ACL Entries associated to the Network
                    List<Map<String, Object>> associatedIngressAclTemplates = NuageVspApiUtil
                            .getACLAssociatedToDomain(network.getUuid(), attachedL2DomainOrDomainId, attachedNetworkType, NuageVspEntity.INGRESS_ACLTEMPLATES, nuageVspAPIParamsAsCmsUser, false);
                    List<Map<String, Object>> associatedEgressAclTemplates = NuageVspApiUtil
                            .getACLAssociatedToDomain(network.getUuid(), attachedL2DomainOrDomainId, attachedNetworkType, NuageVspEntity.EGRESS_ACLTEMPLATES, nuageVspAPIParamsAsCmsUser, false);

                    if (CollectionUtils.isNotEmpty(associatedIngressAclTemplates)) {
                        Map<String, Object> ingressAclTemplate = associatedIngressAclTemplates.iterator().next();
                        ingressACLTempId = (String)ingressAclTemplate.get(NuageVspAttribute.ID.getAttributeName());
                    }

                    if (CollectionUtils.isNotEmpty(associatedEgressAclTemplates)) {
                        Map<String, Object> egressAclTemplate = associatedEgressAclTemplates.iterator().next();
                        egressACLTempId = (String)egressAclTemplate.get(NuageVspAttribute.ID.getAttributeName());
                    }

                    //To set the location field in the ACL get the Subnet Id it is a L3 domain
                    String aclNetworkLocationId = null;
                    if (attachedNetworkType.equals(NuageVspEntity.DOMAIN)) {
                        aclNetworkLocationId = NuageVspApiUtil.findEntityIdByExternalUuid(attachedNetworkType, attachedL2DomainOrDomainId, NuageVspEntity.SUBNET,
                                network.getUuid(), nuageVspAPIParamsAsCmsUser);
                    } else {
                        aclNetworkLocationId = attachedL2DomainOrDomainId;
                    }

                    if (!StringUtils.isBlank(aclNetworkLocationId)) {
                        if (networkReset) {
                            s_logger.debug("Network is restarted to just cleanup the stale " + (isAcsIngressAcl != null ? isAcsIngressAcl ? "Ingress" : "Egress" : "")
                                    + " ACL rules and checking for default rules for " + networkName);
                            resetAllAclRulesInTheNetwork(network, rules, isAcsIngressAcl, attachedNetworkType, attachedL2DomainOrDomainId, networkOferringVO, ingressACLTempId,
                                    egressACLTempId, nuageVspAPIParamsAsCmsUser, vpcOrSubnetUuid, aclNetworkLocationId, !usesPreConfiguredDomainTemplate);
                            return true;
                        }

                        if (StringUtils.isNotBlank(ingressACLTempId) && StringUtils.isNotBlank(egressACLTempId)) {
                            updateACLEntriesInVsp(isNetworkAcl, vpcOrSubnetUuid, network, networkOferringVO, rules, attachedNetworkType, nuageVspAPIParamsAsCmsUser,
                                    aclNetworkLocationId, enterpriseId, ingressACLTempId, egressACLTempId, isAcsIngressAcl, attachedL2DomainOrDomainId, !usesPreConfiguredDomainTemplate);
                        }
                        long updateTime = System.currentTimeMillis();
                        s_logger.debug("Network " + networkName + "(" + random + ")   time taken to process this thread with  " + rules.size() + " rules is "
                                + (updateTime - lockacquiredtime));
                        s_logger.debug("Network " + networkName + "(" + random + ")   total time taken to process this thread with " + rules.size() + " rules is "
                                + (System.currentTimeMillis() - initialStartTime));
                    } else {
                        if (s_logger.isDebugEnabled()) {
                            s_logger.debug("VSP subnet corresponding to network " + network.getName() + " is not found. So, skipping ACL application");
                        }
                    }
                }
            } catch (Exception e1) {
                throw new ResourceUnavailableException(e1.getMessage(), Network.class, network.getId());
            }
        } finally {
            if (network != null && !useConcurrentVsdOps) {
                _networkDao.releaseFromLockTable(network.getId());
            }
        }

        return true;
    }

    private void resetAllAclRulesInTheNetwork(Network network, List<? extends InternalIdentity> rules, Boolean isAcsIngressAcl, NuageVspEntity attachedNetworkType,
            String attachedL2DomainOrDomainId, NetworkOfferingVO networkOferringVO, String ingressACLTempId, String egressACLTempId, NuageVspAPIParams nuageVspAPIParamsAsCmsUser,
            String vpcOrSubnetUuid, String aclNetworkLocationId, boolean createDefaultRules) throws Exception {
        List<Map<String, Object>> ingressACLEntriesAssocToSubnet = NuageVspApiUtil.getACLEntriesAssociatedToLocation(aclNetworkLocationId, NuageVspEntity.INGRESS_ACLTEMPLATES,
                ingressACLTempId, nuageVspAPIParamsAsCmsUser);
        List<Map<String, Object>> egressACLEntriesAssocToSubnet = NuageVspApiUtil.getACLEntriesAssociatedToLocation(aclNetworkLocationId, NuageVspEntity.EGRESS_ACLTEMPLATES,
                egressACLTempId, nuageVspAPIParamsAsCmsUser);
        //Filter all the default ACLs that are associated to the subnet. This information is used by firewall/network ACls
        //provisioning to clean the stale ACL that are associated the subnet
        Map<String, Map<String, Object>> vspIngressAclEntriesExtUuidToAcl = NuageVspApiUtil.filterDefaultACLEntries(ingressACLEntriesAssocToSubnet);
        Map<String, Map<String, Object>> vspEgressAclEntriesExtUuidToAcl = NuageVspApiUtil.filterDefaultACLEntries(egressACLEntriesAssocToSubnet);
        //In Firewall case, get the default ACLs. This information is used to reset the default ACL based on egress policy for firewalls
        Map<Integer, Map<String, Object>> defaultVspIngressAclEntries = null;
        Map<Integer, Map<String, Object>> defaultVspEgressAclEntries = null;
        defaultVspIngressAclEntries = NuageVspApiUtil.getDefaultAclEntries(true, ingressACLTempId, nuageVspAPIParamsAsCmsUser);
        defaultVspEgressAclEntries = NuageVspApiUtil.getDefaultAclEntries(false, egressACLTempId, nuageVspAPIParamsAsCmsUser);

        //This method takes care of trimming any stale ACL entries
        //In case of Firewalls, default ACLs are either added or removed based on the default Egress policy
        //In case of NetworkAcls, all the ACLs are removed if the associated ACL list is empty
        //Then, in both Firewall and NetworkACL, stale ACLs are removed....
        deleteStaleACLEntries(vpcOrSubnetUuid, attachedNetworkType, attachedL2DomainOrDomainId, networkOferringVO.getEgressDefaultPolicy(), aclNetworkLocationId, rules,
                vspIngressAclEntriesExtUuidToAcl, vspEgressAclEntriesExtUuidToAcl, ingressACLTempId, defaultVspIngressAclEntries, egressACLTempId, defaultVspEgressAclEntries,
                network.getName(), isAcsIngressAcl, nuageVspAPIParamsAsCmsUser, createDefaultRules);
    }

    protected List<String> deleteStaleACLEntries(String vpcOrSubnetUuid, NuageVspEntity attachedNetworkType, String attachedL2DomainOrDomainId, boolean egressDefaultPolicy,
            String aclNetworkLocationId, List<? extends InternalIdentity> rules, Map<String, Map<String, Object>> vspIngressAclEntriesExtUuidToAcl,
            Map<String, Map<String, Object>> vspEgressAclEntriesExtUuidToAcl, String ingressACLTempId, Map<Integer, Map<String, Object>> defaultVspIngressAclEntries,
            String egressACLTempId, Map<Integer, Map<String, Object>> defaultVspEgressAclEntries, String networkName, Boolean isAcsIngressAcl,
            NuageVspAPIParams nuageVspAPIParamsAsCmsUser, boolean createDefaultRules) throws Exception {
        List<String> deletedEntries = null;
        //If the default Egress policy is modified, then clean default ACLs based on its value
        if (!egressDefaultPolicy) {
            if (defaultVspIngressAclEntries.size() > 0 || defaultVspEgressAclEntries.size() > 0) {
                deletedEntries = deleteDefaultAclEntries(defaultVspIngressAclEntries, defaultVspEgressAclEntries, networkName, nuageVspAPIParamsAsCmsUser);
            }
        }

        if (createDefaultRules) {
            NuageVspApiUtil.createDefaultIngressAndEgressAcls(false, vpcOrSubnetUuid, egressDefaultPolicy, attachedNetworkType, attachedL2DomainOrDomainId, new StringBuffer(), ingressACLTempId,
                    defaultVspIngressAclEntries, egressACLTempId, defaultVspEgressAclEntries, networkName, nuageVspAPIParamsAsCmsUser);
        }

        //Now handle cleaning up of the Stale ACL entries. These entries need not be restored..
        NuageVspApiUtil.cleanStaleAclsFromVsp(rules, vspIngressAclEntriesExtUuidToAcl, vspEgressAclEntriesExtUuidToAcl, isAcsIngressAcl, nuageVspAPIParamsAsCmsUser);
        return deletedEntries;
    }

    protected List<String> deleteDefaultAclEntries(Map<Integer, Map<String, Object>> defaultVspIngressAclEntries, Map<Integer, Map<String, Object>> defaultVspEgressAclEntries,
            String networkName, NuageVspAPIParams nuageVspAPIParamsAsCmsUser) {
        List<String> cleanedUpVspAclEntryIds = new ArrayList<String>();
        for (Map.Entry<Integer, Map<String, Object>> defaultIngressAclEntry : defaultVspIngressAclEntries.entrySet()) {
            int priority = defaultIngressAclEntry.getKey();
            //Skip the default subnet allow priority
            if (priority != NuageVspConstants.DEFAULT_SUBNET_ALLOW_ACL_PRIORITY) {
                if (NuageVspApiUtil.isDefaultPriorityACL(priority)) {
                    String id = (String)defaultIngressAclEntry.getValue().get(NuageVspAttribute.ID.getAttributeName());
                    if (s_logger.isDebugEnabled()) {
                        s_logger.debug("Default Ingress ACL entries for network " + networkName
                                + " are found and egress policy is deny. Network offering default behavior has been changed. So, delete the default ACLs with VSD ID " + id);
                    }
                    NuageVspApiUtil.cleanUpVspStaleObjects(NuageVspEntity.INGRESS_ACLTEMPLATES_ENTRIES, id, nuageVspAPIParamsAsCmsUser);
                    cleanedUpVspAclEntryIds.add(id);
                }
            } else {
                if (s_logger.isDebugEnabled()) {
                    s_logger.debug("This is a Default Ingress Subnet Allow ACL entries for network " + networkName + " So, this default ACL is not cleaned");
                }
            }
        }
        for (Map.Entry<Integer, Map<String, Object>> defaultEgressAclEntry : defaultVspEgressAclEntries.entrySet()) {
            int priority = defaultEgressAclEntry.getKey();
            //Skip the default subnet allow priority
            if (priority != NuageVspConstants.DEFAULT_SUBNET_ALLOW_ACL_PRIORITY) {
                if (NuageVspApiUtil.isDefaultPriorityACL(priority)) {
                    String id = (String)defaultEgressAclEntry.getValue().get(NuageVspAttribute.ID.getAttributeName());
                    if (s_logger.isDebugEnabled()) {
                        s_logger.debug("Default Egress ACL entries for network " + networkName
                                + " are found and egress policy is deny. Network offering default behavior has been changed. So, delete the default ACLs with VSD ID " + id);
                    }
                    NuageVspApiUtil.cleanUpVspStaleObjects(NuageVspEntity.EGRESS_ACLTEMPLATES_ENTRIES, id, nuageVspAPIParamsAsCmsUser);
                    cleanedUpVspAclEntryIds.add(id);
                }
            } else {
                if (s_logger.isDebugEnabled()) {
                    s_logger.debug("This is a Default Egress Subnet Allow ACL entries for network " + networkName + " So, this default ACL is not cleaned");
                }
            }
        }
        return cleanedUpVspAclEntryIds;
    }

    private void updateACLEntriesInVsp(boolean isNetworkAcl, String vpcOrSubnetUuid, Network network, NetworkOfferingVO networkOferringVO, List<? extends InternalIdentity> rules,
            NuageVspEntity attachedNetworkType, NuageVspAPIParams nuageVspAPIParamsAsCmsUser, String aclNetworkLocationId, String enterpriseId, String ingressACLTempId,
            String egressACLTempId, Boolean isAcsIngressAcl, String attachedL2DomainOrDomainId, boolean createDefaultRules) throws Exception {

        Map<ACLRule, List<String>> finalErrorMap = new HashMap<ACLRule, List<String>>();
        List<String> successfullyAddedIngressACls = new ArrayList<String>();
        List<String> successfullyAddedEgressACls = new ArrayList<String>();
        //This is to add subnet bock when there is egress allow in VPC tier
        int noOfActiveOrAddedAcsEgressAcls = 0;
        //This is to figure if the use case is replace ACL
        int noOfActiveAclsFrmOriginalList = 0;
        for (InternalIdentity acsInputRule : rules) {
            Map<ACLRule, List<String>> errorMap = new HashMap<ACLRule, List<String>>();
            //Convert Firewall Rule and NetworkACLItem to a common ACLRule for easy manipulation
            ACLRule acsAclRule = new ACLRule(acsInputRule, networkOferringVO.getEgressDefaultPolicy());
            if (acsAclRule.getState().equals(ACLRule.ACLState.Add)) {
                noOfActiveOrAddedAcsEgressAcls = noOfActiveOrAddedAcsEgressAcls
                        + createOrModifyACLitems(isNetworkAcl, network, nuageVspAPIParamsAsCmsUser, aclNetworkLocationId, enterpriseId, ingressACLTempId, egressACLTempId,
                                finalErrorMap, successfullyAddedIngressACls, successfullyAddedEgressACls, noOfActiveOrAddedAcsEgressAcls, acsInputRule, errorMap, acsAclRule);

            } else if (acsAclRule.getState().equals(ACLState.Revoke)) {
                revokeACLItems(network, nuageVspAPIParamsAsCmsUser, ingressACLTempId, egressACLTempId, acsAclRule, aclNetworkLocationId);
            } else if (isNetworkAcl && acsAclRule.getState().equals(ACLState.Active)) {
                if (acsAclRule.getTrafficType().equals(ACLTrafficType.Egress) && acsAclRule.getAction().equals(ACLAction.Allow)) {
                    noOfActiveOrAddedAcsEgressAcls++;
                }
            }
            //This is just figure out if all the acl in the original input list is active.
            //this is the case for ACL Replace
            if (isNetworkAcl && ((NetworkACLItem)acsInputRule).getState().equals(NetworkACLItem.State.Active)) {
                noOfActiveAclsFrmOriginalList++;
            }
            if (!isNetworkAcl && ((FirewallRule)acsInputRule).getState().equals(FirewallRule.State.Active)) {
                s_logger.debug("Firewall ACL Rule's original state in input is Active" + acsInputRule + " in network " + network.getName());
                noOfActiveAclsFrmOriginalList++;
            }
        }
        if (noOfActiveAclsFrmOriginalList == rules.size()) {
            s_logger.debug("Number(" + noOfActiveAclsFrmOriginalList + ") of ACL rule in network " + network.getName()
                    + " in Active state matches the input list. This is a ACLList replace scenario or Network Restart. So, processing the ACL lists.");
            resetAllAclRulesInTheNetwork(network, rules, isAcsIngressAcl, attachedNetworkType, attachedL2DomainOrDomainId, networkOferringVO, ingressACLTempId, egressACLTempId,
                    nuageVspAPIParamsAsCmsUser, vpcOrSubnetUuid, aclNetworkLocationId, createDefaultRules);
            for (InternalIdentity rule : rules) {
                Map<ACLRule, List<String>> errorMap = new HashMap<ACLRule, List<String>>();
                ACLRule acsAclRule = new ACLRule(rule, networkOferringVO.getEgressDefaultPolicy());
                noOfActiveOrAddedAcsEgressAcls = noOfActiveOrAddedAcsEgressAcls
                        + createOrModifyACLitems(isNetworkAcl, network, nuageVspAPIParamsAsCmsUser, aclNetworkLocationId, enterpriseId, ingressACLTempId, egressACLTempId,
                                finalErrorMap, successfullyAddedIngressACls, successfullyAddedEgressACls, noOfActiveOrAddedAcsEgressAcls, rule, errorMap, acsAclRule);
                if (errorMap.size() > 0) {
                    finalErrorMap.putAll(errorMap);
                }
            }
        }
        if (isNetworkAcl) {
            if (noOfActiveOrAddedAcsEgressAcls >= 0 && finalErrorMap.size() == 0) {
                Map<ACLRule, List<String>> error = NuageVspApiUtil.createOrDeleteDefaultIngressSubnetBlockAcl(network.getName(), vpcOrSubnetUuid, network.getId(),
                        nuageVspAPIParamsAsCmsUser, aclNetworkLocationId, network.getUuid(), ingressACLTempId, noOfActiveOrAddedAcsEgressAcls);
                if (error.size() > 0) {
                    finalErrorMap.putAll(error);
                }
            }
        }
        if (finalErrorMap.size() > 0) {
            s_logger.error("Failed to create ACLs for network " + network.getName() + " in VSP. " + finalErrorMap + ". So, rolling back the rules VSP Egress ACLs("
                    + successfullyAddedEgressACls + ") and VSP Ingress ACLs (" + successfullyAddedIngressACls + ") that were created in VSP");
            throw new NuageVspAPIUtilException(finalErrorMap.toString());
        }
    }

    private void revokeACLItems(Network network, NuageVspAPIParams nuageVspAPIParamsAsCmsUser, String ingressACLTempId, String egressACLTempId, ACLRule acsAclRule,
            String aclNetworkLocationId) throws NuageVspAPIUtilException {
        //Existing ACL has been removed so delete it
        //figure out all the acls that has to be removed
        String filter = NuageVspAttribute.EXTERNAL_ID.getAttributeName() + " == '" + acsAclRule.getUuid() + "' and "
                + NuageVspAttribute.EGRESS_ACLTEMPLATES_ENTRY_LOCATION_ID.getAttributeName() + " == '" + aclNetworkLocationId + "'";
        if (acsAclRule.getTrafficType().equals(ACLTrafficType.Egress)) {
            String ingressEntry = NuageVspApiUtil.findEntityUsingFilter(NuageVspEntity.INGRESS_ACLTEMPLATES, ingressACLTempId, NuageVspEntity.INGRESS_ACLTEMPLATES_ENTRIES, filter,
                    nuageVspAPIParamsAsCmsUser);
            if (StringUtils.isNotBlank(ingressEntry)) {
                String ingressEntryId = NuageVspApiUtil.getEntityId(ingressEntry, NuageVspEntity.INGRESS_ACLTEMPLATES_ENTRIES);
                if (s_logger.isDebugEnabled()) {
                    s_logger.debug("ACS ACL rule " + acsAclRule + " associated to network " + network.getName() + " is in Revoke state. This ACL " + ingressEntryId
                            + " exists in VSP. So, delete it");
                }
                NuageVspApiUtil.cleanUpVspStaleObjects(NuageVspEntity.INGRESS_ACLTEMPLATES_ENTRIES, ingressEntryId, nuageVspAPIParamsAsCmsUser);
            } else {
                if (s_logger.isDebugEnabled()) {
                    s_logger.debug("ACS ACL rule " + acsAclRule + " associated to network " + network.getName()
                            + " is in Revoke state. But, this ACL does not exist in VSP. So, it is ignored");
                }
            }
        } else if (acsAclRule.getTrafficType().equals(ACLTrafficType.Ingress)) {
            String egressEntry = NuageVspApiUtil.findEntityUsingFilter(NuageVspEntity.EGRESS_ACLTEMPLATES, egressACLTempId, NuageVspEntity.EGRESS_ACLTEMPLATES_ENTRIES, filter,
                    nuageVspAPIParamsAsCmsUser);
            if (StringUtils.isNotBlank(egressEntry)) {
                String egressEntryId = NuageVspApiUtil.getEntityId(egressEntry, NuageVspEntity.EGRESS_ACLTEMPLATES_ENTRIES);
                NuageVspApiUtil.cleanUpVspStaleObjects(NuageVspEntity.EGRESS_ACLTEMPLATES_ENTRIES, egressEntryId, nuageVspAPIParamsAsCmsUser);
                if (s_logger.isDebugEnabled()) {
                    s_logger.debug("ACS ACL rule " + acsAclRule + " associated to network " + network.getName() + " is in Revoke state. This ACL " + egressEntryId
                            + " exists in VSP and it is deleted");
                }
            } else {
                if (s_logger.isDebugEnabled()) {
                    s_logger.debug("ACS ACL rule " + acsAclRule + " associated to network " + network.getName()
                            + " is in Revoke state. But, this ACL does not exist in VSP. So, it is ignored");
                }
            }
        }
    }

    private int createOrModifyACLitems(boolean isNetworkAcl, Network network, NuageVspAPIParams nuageVspAPIParamsAsCmsUser, String aclNetworkLocationId, String enterpriseId,
            String ingressACLTempId, String egressACLTempId, Map<ACLRule, List<String>> finalErrorMap, List<String> successfullyAddedIngressACls,
            List<String> successfullyAddedEgressACls, int noOfActiveOrAddedAcsEgressAcls, InternalIdentity rule, Map<ACLRule, List<String>> errorMap, ACLRule acsAclRule)
            throws NuageVspAPIUtilException {
        String sourceIp = null;
        String filter = NuageVspAttribute.EXTERNAL_ID.getAttributeName() + " == '" + acsAclRule.getUuid() + "' and "
                + NuageVspAttribute.EGRESS_ACLTEMPLATES_ENTRY_LOCATION_ID.getAttributeName() + " == '" + aclNetworkLocationId + "'";
        if (acsAclRule.getTrafficType().equals(ACLTrafficType.Ingress)) {
            if (isNetworkAcl && acsAclRule.getState().equals(ACLState.Add)) {
                String ingressEntry = NuageVspApiUtil.findEntityUsingFilter(NuageVspEntity.INGRESS_ACLTEMPLATES, ingressACLTempId, NuageVspEntity.INGRESS_ACLTEMPLATES_ENTRIES,
                        filter, nuageVspAPIParamsAsCmsUser);
                if (StringUtils.isNotBlank(ingressEntry)) {
                    String ingressEntryId = NuageVspApiUtil.getEntityId(ingressEntry, NuageVspEntity.INGRESS_ACLTEMPLATES_ENTRIES);
                    if (s_logger.isDebugEnabled()) {
                        s_logger.debug("ACS Ingress " + acsAclRule + " is getting added to network " + network.getName() + " but an VSP Ingress rule is with same UUID "
                                + acsAclRule.getUuid() + " already exists"
                                + " in VSP. This means the existing CS Egress rule type has been modified to CS Ingress. So, delete this rule from"
                                + " VSP and create a new Egress rule");
                    }
                    NuageVspApiUtil.cleanUpVspStaleObjects(NuageVspEntity.INGRESS_ACLTEMPLATES_ENTRIES, ingressEntryId, nuageVspAPIParamsAsCmsUser);
                }
            }

            //create a new ACL Entry
            //get the sourceIp information in staticNat rule case
            if (acsAclRule.getSourceIpAddressId() != null) {
                String vmIp = _ipAddressDao.findById(((FirewallRule)rule).getSourceIpAddressId()).getVmIp();
                if (StringUtils.isNotBlank(vmIp)) {
                    sourceIp = vmIp + "/32";
                }
            }
            //Create ACL rule if it does not exists in VSP if the state is Active or Add
            String egressEntry = NuageVspApiUtil.findEntityUsingFilter(NuageVspEntity.EGRESS_ACLTEMPLATES, egressACLTempId, NuageVspEntity.EGRESS_ACLTEMPLATES_ENTRIES, filter,
                    nuageVspAPIParamsAsCmsUser);
            if (StringUtils.isBlank(egressEntry)) {
                //Create a egress ACL in VSP
                errorMap = NuageVspApiUtil.createEgressACLEntryInVsp(isNetworkAcl, enterpriseId, egressACLTempId, acsAclRule, sourceIp, aclNetworkLocationId, network.getId(),
                        successfullyAddedEgressACls, nuageVspAPIParamsAsCmsUser);
                if (s_logger.isDebugEnabled()) {
                    s_logger.debug("ACS Ingress rule "
                            + acsAclRule
                            + " is getting added to network "
                            + network.getName()
                            + " and it does not exists in VSP. The source IP is "
                            + sourceIp
                            + (sourceIp != null ? ". Enterprise macro with same source IP network will be either created if its not present in VSP. Then a rule will be created using the macro"
                                    : ". So, ACL rule is created on the L3 Subnet/L2 Domain with network locationId " + aclNetworkLocationId + " on which the ACL rule is added."));
                }
            } else {
                if (isNetworkAcl) {
                    Map<String, Object> egressEntryData = NuageVspApiUtil.parseJson(egressEntry, NuageVspEntity.EGRESS_ACLTEMPLATES_ENTRIES).iterator().next();
                    String egressEntryId = (String)egressEntryData.get(NuageVspAttribute.ID.getAttributeName());
                    int oldPriority = (Integer)egressEntryData.get(NuageVspAttribute.EGRESS_ACLTEMPLATES_ENTRY_PRIORITY.getAttributeName());
                    errorMap = NuageVspApiUtil.updateEgressACLEntryInVsp(enterpriseId, egressEntryId, egressEntryData, acsAclRule, sourceIp, aclNetworkLocationId, network.getId(),
                            oldPriority, nuageVspAPIParamsAsCmsUser);
                }
            }
        } else if (acsAclRule.getTrafficType().equals(ACLTrafficType.Egress)) {
            if (isNetworkAcl && acsAclRule.getState().equals(ACLState.Add)) {
                String egressEntry = NuageVspApiUtil.findEntityUsingFilter(NuageVspEntity.EGRESS_ACLTEMPLATES, egressACLTempId, NuageVspEntity.EGRESS_ACLTEMPLATES_ENTRIES, filter,
                        nuageVspAPIParamsAsCmsUser);
                if (StringUtils.isNotBlank(egressEntry)) {
                    String egressEntryId = NuageVspApiUtil.getEntityId(egressEntry, NuageVspEntity.EGRESS_ACLTEMPLATES_ENTRIES);
                    NuageVspApiUtil.cleanUpVspStaleObjects(NuageVspEntity.EGRESS_ACLTEMPLATES_ENTRIES, egressEntryId, nuageVspAPIParamsAsCmsUser);
                    if (s_logger.isDebugEnabled()) {
                        s_logger.debug("ACS Egress rule " + acsAclRule + " associated to network " + network.getName()
                                + " is getting added but an VSP Egress rule is with same UUID " + acsAclRule.getUuid() + " already exists"
                                + " in VSP. This means the existing CS Inress rule type has been modified to CS Egress. So, this rule needs is deleted from"
                                + " VSP and a new Ingress rule is created");
                    }
                }
            }
            String ingressEntry = NuageVspApiUtil.findEntityUsingFilter(NuageVspEntity.INGRESS_ACLTEMPLATES, ingressACLTempId, NuageVspEntity.INGRESS_ACLTEMPLATES_ENTRIES, filter,
                    nuageVspAPIParamsAsCmsUser);
            if (StringUtils.isBlank(ingressEntry)) {
                //create a new ACL Entry
                errorMap = NuageVspApiUtil.createIngressACLEntryInVsp(isNetworkAcl, enterpriseId, ingressACLTempId, acsAclRule, aclNetworkLocationId, network.getId(),
                        successfullyAddedIngressACls, nuageVspAPIParamsAsCmsUser);
                if (s_logger.isDebugEnabled()) {
                    s_logger.debug("ACS Egress rule " + acsAclRule + " associated to network " + network.getName() + " is getting added and does not exists in VSP."
                            + "So, ACL rule is created on the L3 Subnet/L2 Domain with network locationId " + aclNetworkLocationId + " on which the ACL rule is added.");
                }
            } else {
                if (isNetworkAcl) {
                    Map<String, Object> ingressEntryData = NuageVspApiUtil.parseJson(ingressEntry, NuageVspEntity.INGRESS_ACLTEMPLATES_ENTRIES).iterator().next();
                    String ingressEntryId = (String)ingressEntryData.get(NuageVspAttribute.ID.getAttributeName());
                    int oldPriority = (Integer)ingressEntryData.get(NuageVspAttribute.INGRESS_ACLTEMPLATES_ENTRY_PRIORITY.getAttributeName());
                    errorMap = NuageVspApiUtil.updateIngressACLEntryInVsp(enterpriseId, ingressEntryId, ingressEntryData, acsAclRule, aclNetworkLocationId, network.getId(),
                            oldPriority, nuageVspAPIParamsAsCmsUser);
                }
            }
            if (isNetworkAcl && acsAclRule.getAction().equals(ACLAction.Allow)) {
                noOfActiveOrAddedAcsEgressAcls++;
            }
        }
        if (errorMap != null && errorMap.size() > 0) {
            finalErrorMap.putAll(errorMap);
        }
        return noOfActiveOrAddedAcsEgressAcls;
    }

    @Override
    public HostVO createHostVOForConnectedAgent(HostVO host, StartupCommand[] cmd) {
        return null;
    }

    @Override
    public HostVO createHostVOForDirectConnectAgent(HostVO host, StartupCommand[] startup, ServerResource resource, Map<String, String> details, List<String> hostTags) {
        if (!(startup[0] instanceof StartupNuageVspCommand)) {
            return null;
        }
        host.setType(Host.Type.L2Networking);
        return host;
    }

    @Override
    public DeleteHostAnswer deleteHost(HostVO host, boolean isForced, boolean isForceDeleteStorage) throws UnableDeleteHostException {
        if (!(host.getType() == Host.Type.L2Networking)) {
            return null;
        }
        return new DeleteHostAnswer(true);
    }

    protected HostVO getNuageVspHost(Long physicalNetworkId) throws NuageVspAPIUtilException {
        // TODO: Cache this as we don't want a DB hit everytime we send a message to VSD
        HostVO nuageVspHost;
        List<NuageVspDeviceVO> nuageVspDevices = _nuageVspDao.listByPhysicalNetwork(physicalNetworkId);
        if (nuageVspDevices != null && (!nuageVspDevices.isEmpty())) {
            NuageVspDeviceVO config = nuageVspDevices.iterator().next();
            nuageVspHost = _hostDao.findById(config.getHostId());
            _hostDao.loadDetails(nuageVspHost);
        } else {
            throw new NuageVspAPIUtilException("Nuage VSD is not configured on physical network " + physicalNetworkId);
        }
        return nuageVspHost;
    }
}
